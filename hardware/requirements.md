# Arch-Stats Sensor Requirements (Electronics Spec v0.2)

- [Arch-Stats Sensor Requirements (Electronics Spec v0.2)](#arch-stats-sensor-requirements-electronics-spec-v02)
  - [1 Project goals](#1-project-goals)
  - [2 System overview and hard constraints](#2-system-overview-and-hard-constraints)
  - [3 Data contracts (exact fields backend needs)](#3-data-contracts-exact-fields-backend-needs)
    - [3.1 Shots data (table `shots`)](#31-shots-data-table-shots)
    - [3.2 Arrow programming data (table `arrows`)](#32-arrow-programming-data-table-arrows)
  - [4 Functional requirements by device](#4-functional-requirements-by-device)
    - [4.1 Bow sensor (wireless)](#41-bow-sensor-wireless)
    - [4.2 Target sensor (wired)](#42-target-sensor-wired)
    - [4.3 Arrow scanner (wired)](#43-arrow-scanner-wired)
  - [5 RFID requirements (to be finalized by EE)](#5-rfid-requirements-to-be-finalized-by-ee)
  - [6 Communication, latency, and synchronization](#6-communication-latency-and-synchronization)
  - [7 Environmental, mechanical, and compliance](#7-environmental-mechanical-and-compliance)
  - [8 Open questions for Electronic Engineering (please fill)](#8-open-questions-for-electronic-engineering-please-fill)
    - [8.1 Wireless for bow sensor](#81-wireless-for-bow-sensor)
    - [8.2 Power and battery (bow sensor)](#82-power-and-battery-bow-sensor)
    - [8.3 RFID](#83-rfid)
    - [8.4 Target impact sensing](#84-target-impact-sensing)
    - [8.5 Interfaces to RPi 5](#85-interfaces-to-rpi-5)
    - [8.6 Timekeeping](#86-timekeeping)
    - [8.7 Mechanical and environmental](#87-mechanical-and-environmental)
    - [8.8 Compliance \& test](#88-compliance--test)
  - [9 Acceptance criteria (initial)](#9-acceptance-criteria-initial)

Audience: Electronic Engineers responsible for hardware design, firmware, and sensor integration.

This document states the project's goals, hard constraints, exact data the backend needs, and a checklist of open questions for you to fill. The Raspberry Pi 5 (RPi 5) is the hub/brain; all sensors connect to it.

## 1 Project goals

1. Collect shot data to satisfy backend model `shots` (see mapping below).
2. Provide a reliable way to program arrows with a given UUID (see `arrows` mapping below).

## 2 System overview and hard constraints

- Hub: Raspberry Pi 5 (RPi 5) runs the backend and orchestrates sensors.
- Connectivity rules:
  - Bow sensor: wireless link to RPi 5. Required range: 10 - 30 meters minimum; up to 70 meters nice-to-have.
  - Target sensor(s): may be wired to RPi 5.
  - Arrow reader/scanner (used to program arrows): may be wired to RPi 5.
- All timestamps must be UTC, ISO 8601 with millisecond precision.
- Environment: indoors and outdoors in all weather (rain, dust, direct sunlight). Hardware must be robust under typical range conditions.
- Coordinate precision: millimetre-level at the target to resolve ring-line touches.

Notes for interface planning:

- RPi 5 offers multiple interfaces (GPIO/UART/SPI/I2C/USB, etc.). Please propose the preferred interface(s) per device; avoid exotic add-ons unless justified.

## 3 Data contracts (exact fields backend needs)

The backend stores two core things relevant to hardware: shots and arrows. Below are the fields and which device is expected to produce them.

### 3.1 Shots data (table `shots`)

Required fields and sources (backend schema reference):

- id: UUID (generated by backend, not by hardware).
- arrow_id: UUID (from arrow tag; see RFID requirements). Source: bow or target sensor.
- session_id: UUID (assigned by backend; not a sensor output).
- arrow_engage_time: timestamp with tz (UTC, ms). Source: bow sensor.
- arrow_disengage_time: timestamp with tz (UTC, ms). Source: bow sensor.
- arrow_landing_time: timestamp with tz (UTC, ms) OR null. Source: target sensor.
- x: real (mm) OR null. Source: target sensor.
- y: real (mm) OR null. Source: target sensor.

Contract rules enforced by DB:

- Landing triple consistency: `arrow_landing_time`, `x`, `y` must be all non-null (a scored hit) or all null (a miss).
- Miss rule: if no landing is detected within a configurable window after disengage, backend will store a miss (landing triple null). Hardware should expose a parameter to tune this window or provide a reliable absence-of-impact signal.

Recommended timing model (please confirm):

- Sensors send events ASAP; RPi 5 timestamps upon receipt to standardize time base. If on-device timestamps are used, ensure clock sync method and worst-case drift are documented.

### 3.2 Arrow programming data (table `arrows`)

Fields and constraints the programming workflow must satisfy:

- id: UUID (assigned during registration; permanent; never reassigned).
- human_identifier: string (<= 10 chars), unique, operator-friendly label printed on arrow.
- is_programmed: boolean flag reflecting whether the physical arrow's tag successfully holds the UUID.
- registration_date: auto by backend.
- voided_date, is_active: backend maintenance flags (not part of programming HW path).
- Optional numeric traits captured during registration UI and stored by backend (can be measured/entered by user; not required from hardware):
  - length, label_position, weight, diameter, spine (units in mm/grams as applicable).

Programming device output:

- programming_status: true/false indicating tag write success; must be aligned to `is_programmed` in DB.

UUID policy:

- Each arrow UUID is permanent. No reassignment, deletion, or overwrite.

## 4 Functional requirements by device

### 4.1 Bow sensor (wireless)

Mount: as close as practical to the arrow; extremely lightweight.

Power:

- Minimum operating time: 4 h on a single charge; target 6 h.

Functions:

- Detect arrow engaged (nocked) and arrow release (leaves string).
- Read the engaged arrow's UHF RFID tag at a few cm reliably and exclusively (reject other tags nearby).
- Transmit: `arrow_id`, `arrow_engage_time`, `arrow_disengage_time` to RPi 5.

Status indicators (suggested; can be adapted):

- Solid green: powered and ready.
- Solid red: arrow engaged.
- Blinking red: communication failure with RPi 5.
- Nice-to-have: low battery indicator (pattern TBD).

Wireless link:

- Range: 10 - 30 meters min; 70 meters nice-to-have.
- Latency and reliability sufficient to avoid event loss or reordering (please propose budget).
- Protocol TBD (BLE/2.4 GHz Sub-GHz/Wi-Fi/etc.). Avoid interference with UHF RFID.

### 4.2 Target sensor (wired)

Placement: RPi 5 near the target butt; wiring allowed. Sensor configuration should adapt to different butt sizes.

Modes:

- Target Calibration (once per session):
  - Determine `max_x`, `max_y` (butt extents or sensor scope).
  - Detect up to 3 target faces; for each face: center `(x,y)` and radii array (per scoring ring).

- Shooting (repeated during session):
  - Read UHF RFID of landing arrow up to ~1.5 m (depends on materials/size).
  - Detect impact coordinates `(x, y)` at mm precision.

Outputs:

- Calibration:
  - max_x, max_y (mm).
  - target_faces: array of faces with center `(x,y)` and ring `radii[]` (mm).
- Shooting:
  - arrow_id (UUID), arrow_landing_time (UTC, ms), x (mm), y (mm).

Edge cases:

- Overlapping impacts must be handled deterministically (define tie-break strategy or multi-hit reporting capability).
- Misses: if a corresponding landing isn't detected within timeout after release, no landing triple is sent; backend records a miss.

Coordinate system:

- Units: millimetres.
- Define origin, axes orientation, and which direction is +x/+y (please specify and keep consistent across calibration and shooting).

### 4.3 Arrow scanner (wired)

Usage: manual, one arrow at a time during registration.

Functions:

- Program arrow tag with provided UUID from backend.
- Read-back/verify to ensure tag matches expected UUID.

Output:

- programming_status: true on successful write & verify; false otherwise.

Policy:

- UUID permanence enforced by software; device must never erase/override an already programmed arrow.

## 5 RFID requirements (to be finalized by EE)

- Select appropriate UHF RFID standard and readers/antennae.
- Bow sensor: near-field read at a few cm; must target only engaged arrow's tag (anti-collision, shielding, orientation as needed).
- Target sensor: read up to ~1.5 m; handle tag orientations and materials.
- Tag placement: depends on bow sensor location and draw length please propose validated positions.

## 6 Communication, latency, and synchronization

- Bow->RPi 5 wireless: propose protocol, PHY, data rate, error handling, and reconnection strategies.
- Timestamping: prefer unified time base at RPi; if on-device timestamps are used, specify clock source, drift, and sync interval.
- End-to-end latency budget: please propose (release->RPi receipt), ensuring software can infer misses reliably.

## 7 Environmental, mechanical, and compliance

- Operate indoors and outdoors in varying weather (rain, dust, sunlight). Propose enclosure/IP rating and operating temperature range.
- Shock/vibration: typical archery usage; ensure mounting doesn't affect performance.
- Safety and regulatory compliance for RF emissions and batteries (region-dependent).

## 8 Open questions for Electronic Engineering (please fill)

### 8.1 Wireless for bow sensor

- Proposed protocol/SoC/module and antenna design.
- Expected range (clear line-of-sight vs obstructed), link budget, and latency.
- Coexistence plan with UHF RFID and other 2.4 GHz devices.

### 8.2 Power and battery (bow sensor)

- Battery chemistry/capacity, charge strategy, connector, protections.
- Estimated current draw per mode and resulting runtime (min/typ/max).
- Low-battery signaling strategy.

### 8.3 RFID

- Chosen UHF standard, tag type/model, reader IC/module for bow and target.
- Antenna design, tuning, and shielding for selective reads at bow.
- Verified tag placement options and tolerances.

### 8.4 Target impact sensing

- Sensing technology for mm coordinate resolution and overlapping hit handling.
- Calibration method and procedure repeatability; drift over time/temperature.

### 8.5 Interfaces to RPi 5

- Exact interfaces per device (USB/UART/SPI/I2C/GPIO), cabling lengths, and connectors.
- Message formats over each link (payload examples for engage, release, landing, calibration data, errors).

### 8.6 Timekeeping

- Will sensors timestamp events or will RPi 5 do so on receipt? If sensors stamp, specify clock source and sync.

### 8.7 Mechanical and environmental

- Mounting concepts for bow and target; mass and balance impact analysis for bow.
- Enclosure rating, temperature/humidity specs.

### 8.8 Compliance & test

- EMC/RF and battery compliance targets per region.
- Bring-up and production test plan (fixtures, self-test, diagnostics).

## 9 Acceptance criteria (initial)

- Bow sensor operates 3 hours (6 hours desirable), wirelessly sends engage/release + arrow_id at required ranges.
- Target sensor provides calibration data and per-shot `(arrow_id, landing_time, x, y)` at mm precision.
- Arrow scanner reliably programs and verifies UUIDs with permanent, non-overwritable policy.
- All events timestamped in UTC ISO 8601 with millisecond precision and delivered to RPi 5 without loss under normal conditions.

The bow and target sensors must work together to produce complete shot data across distances of 10 - 30 meters minimum, up to 70 m desirable. All sensors connect to and are coordinated by the Raspberry Pi 5.

**NOTE:** All timestamps must use UTC in ISO 8601 format with millisecond precision.
